{"version":3,"file":"svg-points.min.js","sources":["../src/toPoints.js","../src/toPath.js","../src/valid.js"],"sourcesContent":["const toPoints = ({ type, ...props }) => {\n  switch (type) {\n    case 'circle':\n      return getPointsFromCircle(props)\n    case 'ellipse':\n      return getPointsFromEllipse(props)\n    case 'line':\n      return getPointsFromLine(props)\n    case 'path':\n      return getPointsFromPath(props)\n    case 'polygon':\n      return getPointsFromPolygon(props)\n    case 'polyline':\n      return getPointsFromPolyline(props)\n    case 'rect':\n      return getPointsFromRect(props)\n    case 'g':\n      return getPointsFromG(props)\n    default:\n      throw new Error('Not a valid shape type')\n  }\n}\n\nconst getPointsFromCircle = ({ cx, cy, r }) => {\n  return [\n    { x: cx, y: cy - r, moveTo: true },\n    { x: cx, y: cy + r, curve: { type: 'arc', rx: r, ry: r, sweepFlag: 1 } },\n    { x: cx, y: cy - r, curve: { type: 'arc', rx: r, ry: r, sweepFlag: 1 } }\n  ]\n}\n\nconst getPointsFromEllipse = ({ cx, cy, rx, ry }) => {\n  return [\n    { x: cx, y: cy - ry, moveTo: true },\n    { x: cx, y: cy + ry, curve: { type: 'arc', rx, ry, sweepFlag: 1 } },\n    { x: cx, y: cy - ry, curve: { type: 'arc', rx, ry, sweepFlag: 1 } }\n  ]\n}\n\nconst getPointsFromLine = ({ x1, x2, y1, y2 }) => {\n  return [\n    { x: x1, y: y1, moveTo: true },\n    { x: x2, y: y2 }\n  ]\n}\n\nconst validCommands = /[MmLlHhVvCcSsQqTtAaZz]/g\n\nconst commandLengths = {\n  A: 7,\n  C: 6,\n  H: 1,\n  L: 2,\n  M: 2,\n  Q: 4,\n  S: 4,\n  T: 2,\n  V: 1,\n  Z: 0\n}\n\nconst relativeCommands = [\n  'a',\n  'c',\n  'h',\n  'l',\n  'm',\n  'q',\n  's',\n  't',\n  'v'\n]\n\nconst isRelative = command => relativeCommands.indexOf(command) !== -1\n\nconst optionalArcKeys = [ 'xAxisRotation', 'largeArcFlag', 'sweepFlag' ]\n\nconst getCommands = d => d.match(validCommands)\n\nconst getParams = d => d.split(validCommands)\n  .map(v => v.replace(/[0-9]+-/g, m => `${m.slice(0, -1)} -`))\n  .map(v => v.replace(/\\.[0-9]+/g, m => `${m} `))\n  .map(v => v.trim())\n  .filter(v => v.length > 0)\n  .map(v => v.split(/[ ,]+/)\n    .map(parseFloat)\n    .filter(n => !isNaN(n))\n  )\n\nconst getPointsFromPath = ({ d }) => {\n  const commands = getCommands(d)\n  const params = getParams(d)\n\n  const points = []\n\n  let moveTo\n\n  for (let i = 0, l = commands.length; i < l; i++) {\n    const command = commands[ i ]\n    const upperCaseCommand = command.toUpperCase()\n    const commandLength = commandLengths[ upperCaseCommand ]\n    const relative = isRelative(command)\n\n    if (commandLength > 0) {\n      const commandParams = params.shift()\n      const iterations = commandParams.length / commandLength\n\n      for (let j = 0; j < iterations; j++) {\n        const prevPoint = points[ points.length - 1 ] || { x: 0, y: 0 }\n\n        switch (upperCaseCommand) {\n          case 'M':\n            const x = (relative ? prevPoint.x : 0) + commandParams.shift()\n            const y = (relative ? prevPoint.y : 0) + commandParams.shift()\n\n            if (j === 0) {\n              moveTo = { x, y }\n              points.push({ x, y, moveTo: true })\n            } else {\n              points.push({ x, y })\n            }\n\n            break\n\n          case 'L':\n            points.push({\n              x: (relative ? prevPoint.x : 0) + commandParams.shift(),\n              y: (relative ? prevPoint.y : 0) + commandParams.shift()\n            })\n\n            break\n\n          case 'H':\n            points.push({\n              x: (relative ? prevPoint.x : 0) + commandParams.shift(),\n              y: prevPoint.y\n            })\n\n            break\n\n          case 'V':\n            points.push({\n              x: prevPoint.x,\n              y: (relative ? prevPoint.y : 0) + commandParams.shift()\n            })\n\n            break\n\n          case 'A':\n            points.push({\n              curve: {\n                type: 'arc',\n                rx: commandParams.shift(),\n                ry: commandParams.shift(),\n                xAxisRotation: commandParams.shift(),\n                largeArcFlag: commandParams.shift(),\n                sweepFlag: commandParams.shift()\n              },\n              x: (relative ? prevPoint.x : 0) + commandParams.shift(),\n              y: (relative ? prevPoint.y : 0) + commandParams.shift()\n            })\n\n            for (let k of optionalArcKeys) {\n              if (points[ points.length - 1 ][ 'curve' ][ k ] === 0) {\n                delete points[ points.length - 1 ][ 'curve' ][ k ]\n              }\n            }\n\n            break\n\n          case 'C':\n            points.push({\n              curve: {\n                type: 'cubic',\n                x1: (relative ? prevPoint.x : 0) + commandParams.shift(),\n                y1: (relative ? prevPoint.y : 0) + commandParams.shift(),\n                x2: (relative ? prevPoint.x : 0) + commandParams.shift(),\n                y2: (relative ? prevPoint.y : 0) + commandParams.shift()\n              },\n              x: (relative ? prevPoint.x : 0) + commandParams.shift(),\n              y: (relative ? prevPoint.y : 0) + commandParams.shift()\n            })\n\n            break\n\n          case 'S':\n            const sx2 = (relative ? prevPoint.x : 0) + commandParams.shift()\n            const sy2 = (relative ? prevPoint.y : 0) + commandParams.shift()\n            const sx = (relative ? prevPoint.x : 0) + commandParams.shift()\n            const sy = (relative ? prevPoint.y : 0) + commandParams.shift()\n\n            const diff = {}\n\n            let sx1\n            let sy1\n\n            if (prevPoint.curve && prevPoint.curve.type === 'cubic') {\n              diff.x = Math.abs(prevPoint.x - prevPoint.curve.x2)\n              diff.y = Math.abs(prevPoint.y - prevPoint.curve.y2)\n              sx1 = prevPoint.x < prevPoint.curve.x2 ? prevPoint.x - diff.x : prevPoint.x + diff.x\n              sy1 = prevPoint.y < prevPoint.curve.y2 ? prevPoint.y - diff.y : prevPoint.y + diff.y\n            } else {\n              diff.x = Math.abs(sx - sx2)\n              diff.y = Math.abs(sy - sy2)\n              sx1 = prevPoint.x\n              sy1 = prevPoint.y\n            }\n\n            points.push({ curve: { type: 'cubic', x1: sx1, y1: sy1, x2: sx2, y2: sy2 }, x: sx, y: sy })\n\n            break\n\n          case 'Q':\n            points.push({\n              curve: {\n                type: 'quadratic',\n                x1: (relative ? prevPoint.x : 0) + commandParams.shift(),\n                y1: (relative ? prevPoint.y : 0) + commandParams.shift()\n              },\n              x: (relative ? prevPoint.x : 0) + commandParams.shift(),\n              y: (relative ? prevPoint.y : 0) + commandParams.shift()\n            })\n\n            break\n\n          case 'T':\n            const tx = (relative ? prevPoint.x : 0) + commandParams.shift()\n            const ty = (relative ? prevPoint.y : 0) + commandParams.shift()\n\n            let tx1\n            let ty1\n\n            if (prevPoint.curve && prevPoint.curve.type === 'quadratic') {\n              const diff = {\n                x: Math.abs(prevPoint.x - prevPoint.curve.x1),\n                y: Math.abs(prevPoint.y - prevPoint.curve.y1)\n              }\n\n              tx1 = prevPoint.x < prevPoint.curve.x1 ? prevPoint.x - diff.x : prevPoint.x + diff.x\n              ty1 = prevPoint.y < prevPoint.curve.y1 ? prevPoint.y - diff.y : prevPoint.y + diff.y\n            } else {\n              tx1 = prevPoint.x\n              ty1 = prevPoint.y\n            }\n\n            points.push({ curve: { type: 'quadratic', x1: tx1, y1: ty1 }, x: tx, y: ty })\n\n            break\n        }\n      }\n    } else {\n      const prevPoint = points[ points.length - 1 ] || { x: 0, y: 0 }\n\n      if (prevPoint.x !== moveTo.x || prevPoint.y !== moveTo.y) {\n        points.push({ x: moveTo.x, y: moveTo.y })\n      }\n    }\n  }\n\n  return points\n}\n\nconst getPointsFromPolygon = ({ points }) => {\n  return getPointsFromPoints({ closed: true, points })\n}\n\nconst getPointsFromPolyline = ({ points }) => {\n  return getPointsFromPoints({ closed: false, points })\n}\n\nconst getPointsFromPoints = ({ closed, points }) => {\n  const numbers = points.split(/[\\s,]+/).map(n => parseFloat(n))\n\n  const p = numbers.reduce((arr, point, i) => {\n    if (i % 2 === 0) {\n      arr.push({ x: point })\n    } else {\n      arr[ (i - 1) / 2 ].y = point\n    }\n\n    return arr\n  }, [])\n\n  if (closed) {\n    p.push({ ...p[ 0 ] })\n  }\n\n  p[ 0 ].moveTo = true\n\n  return p\n}\n\nconst getPointsFromRect = ({ height, rx, ry, width, x, y }) => {\n  if (rx || ry) {\n    return getPointsFromRectWithCornerRadius({\n      height,\n      rx: rx || ry,\n      ry: ry || rx,\n      width,\n      x,\n      y\n    })\n  }\n\n  return getPointsFromBasicRect({ height, width, x, y })\n}\n\nconst getPointsFromBasicRect = ({ height, width, x, y }) => {\n  return [\n    { x, y, moveTo: true },\n    { x: x + width, y },\n    { x: x + width, y: y + height },\n    { x, y: y + height },\n    { x, y }\n  ]\n}\n\nconst getPointsFromRectWithCornerRadius = ({ height, rx, ry, width, x, y }) => {\n  const curve = { type: 'arc', rx, ry, sweepFlag: 1 }\n\n  return [\n    { x: x + rx, y, moveTo: true },\n    { x: x + width - rx, y },\n    { x: x + width, y: y + ry, curve },\n    { x: x + width, y: y + height - ry },\n    { x: x + width - rx, y: y + height, curve },\n    { x: x + rx, y: y + height },\n    { x, y: y + height - ry, curve },\n    { x, y: y + ry },\n    { x: x + rx, y, curve }\n  ]\n}\n\nconst getPointsFromG = ({ shapes }) => shapes.map(s => toPoints(s))\n\nexport default toPoints\n","import toPoints from './toPoints'\n\nconst pointsToD = p => {\n  let d = ''\n  let i = 0\n  let firstPoint\n\n  for (let point of p) {\n    const { curve = false, moveTo, x, y } = point\n    const isFirstPoint = i === 0 || moveTo\n    const isLastPoint = i === p.length - 1 || p[ i + 1 ].moveTo\n    const prevPoint = i === 0 ? null : p[ i - 1 ]\n\n    if (isFirstPoint) {\n      firstPoint = point\n\n      if (!isLastPoint) {\n        d += `M${x},${y}`\n      }\n    } else if (curve) {\n      switch (curve.type) {\n        case 'arc':\n          const { largeArcFlag = 0, rx, ry, sweepFlag = 0, xAxisRotation = 0 } = point.curve\n          d += `A${rx},${ry},${xAxisRotation},${largeArcFlag},${sweepFlag},${x},${y}`\n          break\n        case 'cubic':\n          const { x1: cx1, y1: cy1, x2: cx2, y2: cy2 } = point.curve\n          d += `C${cx1},${cy1},${cx2},${cy2},${x},${y}`\n          break\n        case 'quadratic':\n          const { x1: qx1, y1: qy1 } = point.curve\n          d += `Q${qx1},${qy1},${x},${y}`\n          break\n      }\n\n      if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {\n        d += 'Z'\n      }\n    } else if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {\n      d += 'Z'\n    } else if (x !== prevPoint.x && y !== prevPoint.y) {\n      d += `L${x},${y}`\n    } else if (x !== prevPoint.x) {\n      d += `H${x}`\n    } else if (y !== prevPoint.y) {\n      d += `V${y}`\n    }\n\n    i++\n  }\n\n  return d\n}\n\nconst toPath = s => {\n  const isPoints = Array.isArray(s)\n  const isGroup = isPoints ? (Array.isArray(s[ 0 ])) : (s.type === 'g')\n  const points = isPoints ? s : (isGroup ? s.shapes.map(shp => toPoints(shp)) : toPoints(s))\n\n  if (isGroup) {\n    return points.map(p => pointsToD(p))\n  }\n\n  return pointsToD(points)\n}\n\nexport default toPath\n","const getErrors = shape => {\n  const rules = getRules(shape)\n  const errors = []\n\n  rules.map(({ match, prop, required, type }) => {\n    if (typeof shape[ prop ] === 'undefined') {\n      if (required) {\n        errors.push(\n          `${prop} prop is required${prop === 'type' ? '' : ` on a ${shape.type}`}`\n        )\n      }\n    } else {\n      if (typeof type !== 'undefined') {\n        if (type === 'array') {\n          if (!Array.isArray(shape[ prop ])) {\n            errors.push(`${prop} prop must be of type array`)\n          }\n        } else if (typeof shape[ prop ] !== type) { // eslint-disable-line valid-typeof\n          errors.push(`${prop} prop must be of type ${type}`)\n        }\n      }\n\n      if (Array.isArray(match)) {\n        if (match.indexOf(shape[ prop ]) === -1) {\n          errors.push(`${prop} prop must be one of ${match.join(', ')}`)\n        }\n      }\n    }\n  })\n\n  if (shape.type === 'g' && Array.isArray(shape.shapes)) {\n    const childErrors = shape.shapes.map(s => getErrors(s))\n    return [].concat.apply(errors, childErrors)\n  }\n\n  return errors\n}\n\nconst getRules = shape => {\n  const rules = [{\n    match: [\n      'circle',\n      'ellipse',\n      'line',\n      'path',\n      'polygon',\n      'polyline',\n      'rect',\n      'g'\n    ],\n    prop: 'type',\n    required: true,\n    type: 'string'\n  }]\n\n  switch (shape.type) {\n    case 'circle':\n      rules.push({ prop: 'cx', required: true, type: 'number' })\n      rules.push({ prop: 'cy', required: true, type: 'number' })\n      rules.push({ prop: 'r', required: true, type: 'number' })\n      break\n\n    case 'ellipse':\n      rules.push({ prop: 'cx', required: true, type: 'number' })\n      rules.push({ prop: 'cy', required: true, type: 'number' })\n      rules.push({ prop: 'rx', required: true, type: 'number' })\n      rules.push({ prop: 'ry', required: true, type: 'number' })\n      break\n\n    case 'line':\n      rules.push({ prop: 'x1', required: true, type: 'number' })\n      rules.push({ prop: 'x2', required: true, type: 'number' })\n      rules.push({ prop: 'y1', required: true, type: 'number' })\n      rules.push({ prop: 'y2', required: true, type: 'number' })\n      break\n\n    case 'path':\n      rules.push({ prop: 'd', required: true, type: 'string' })\n      break\n\n    case 'polygon':\n    case 'polyline':\n      rules.push({ prop: 'points', required: true, type: 'string' })\n      break\n\n    case 'rect':\n      rules.push({ prop: 'height', required: true, type: 'number' })\n      rules.push({ prop: 'rx', type: 'number' })\n      rules.push({ prop: 'ry', type: 'number' })\n      rules.push({ prop: 'width', required: true, type: 'number' })\n      rules.push({ prop: 'x', required: true, type: 'number' })\n      rules.push({ prop: 'y', required: true, type: 'number' })\n      break\n\n    case 'g':\n      rules.push({ prop: 'shapes', required: true, type: 'array' })\n      break\n  }\n\n  return rules\n}\n\nconst valid = shape => {\n  const errors = getErrors(shape)\n\n  return {\n    errors,\n    valid: errors.length === 0\n  }\n}\n\nexport default valid\n"],"names":["toPoints","type","props","getPointsFromCircle","getPointsFromEllipse","getPointsFromLine","getPointsFromPath","getPointsFromPolygon","getPointsFromPolyline","getPointsFromRect","getPointsFromG","Error","cx","cy","r","x","y","moveTo","curve","rx","ry","sweepFlag","x1","x2","y1","y2","validCommands","commandLengths","relativeCommands","isRelative","indexOf","command","optionalArcKeys","getCommands","d","match","getParams","split","map","v","replace","m","slice","trim","filter","length","parseFloat","isNaN","n","commands","params","points","i","l","upperCaseCommand","toUpperCase","commandLength","relative","commandParams","shift","iterations","j","prevPoint","push","k","sx2","sy2","sx","sy","diff","sx1","sy1","Math","abs","tx","ty","tx1","ty1","getPointsFromPoints","closed","p","reduce","arr","point","height","width","getPointsFromRectWithCornerRadius","getPointsFromBasicRect","shapes","s","pointsToD","firstPoint","isFirstPoint","isLastPoint","largeArcFlag","xAxisRotation","getErrors","errors","getRules","shape","prop","required","Array","isArray","babelHelpers.typeof","join","childErrors","concat","apply","rules","isPoints","isGroup","shp"],"mappings":"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"}