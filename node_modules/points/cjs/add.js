"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.curvedPoints = void 0;

var _cubify = _interopRequireDefault(require("./cubify"));

var _helpers = require("./helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var linearPoints = function linearPoints(from, to) {
  return [{
    x: (0, _helpers.numberAtInterval)(from.x, to.x, 0.5),
    y: (0, _helpers.numberAtInterval)(from.y, to.y, 0.5)
  }, to];
};

var curvedPoints = function curvedPoints(from, to) {
  var _to$curve = to.curve,
      x1 = _to$curve.x1,
      y1 = _to$curve.y1,
      x2 = _to$curve.x2,
      y2 = _to$curve.y2;
  var A = {
    x: from.x,
    y: from.y
  };
  var B = {
    x: x1,
    y: y1
  };
  var C = {
    x: x2,
    y: y2
  };
  var D = {
    x: to.x,
    y: to.y
  };
  var E = {
    x: (0, _helpers.numberAtInterval)(A.x, B.x, 0.5),
    y: (0, _helpers.numberAtInterval)(A.y, B.y, 0.5)
  };
  var F = {
    x: (0, _helpers.numberAtInterval)(B.x, C.x, 0.5),
    y: (0, _helpers.numberAtInterval)(B.y, C.y, 0.5)
  };
  var G = {
    x: (0, _helpers.numberAtInterval)(C.x, D.x, 0.5),
    y: (0, _helpers.numberAtInterval)(C.y, D.y, 0.5)
  };
  var H = {
    x: (0, _helpers.numberAtInterval)(E.x, F.x, 0.5),
    y: (0, _helpers.numberAtInterval)(E.y, F.y, 0.5)
  };
  var J = {
    x: (0, _helpers.numberAtInterval)(F.x, G.x, 0.5),
    y: (0, _helpers.numberAtInterval)(F.y, G.y, 0.5)
  };
  var K = {
    x: (0, _helpers.numberAtInterval)(H.x, J.x, 0.5),
    y: (0, _helpers.numberAtInterval)(H.y, J.y, 0.5)
  };
  return [{
    x: K.x,
    y: K.y,
    curve: {
      type: 'cubic',
      x1: E.x,
      y1: E.y,
      x2: H.x,
      y2: H.y
    }
  }, {
    x: D.x,
    y: D.y,
    curve: {
      type: 'cubic',
      x1: J.x,
      y1: J.y,
      x2: G.x,
      y2: G.y
    }
  }];
};

exports.curvedPoints = curvedPoints;

var points = function points(from, to) {
  return to.curve ? curvedPoints(from, to) : linearPoints(from, to);
};

var addPoints = function addPoints(shape, pointsRequired) {
  if (isNaN(pointsRequired)) {
    throw Error('`add` function must be passed a number as the second argument');
  }

  var nextShape = _toConsumableArray(shape);

  for (var i = 1; i < nextShape.length;) {
    if (nextShape.length >= pointsRequired) {
      return nextShape;
    }

    var to = nextShape[i];

    if (to.moveTo) {
      i++;
    } else {
      var from = nextShape[i - 1];

      var _points = points(from, to),
          _points2 = _slicedToArray(_points, 2),
          midPoint = _points2[0],
          replacementPoint = _points2[1];

      nextShape.splice(i, 1, midPoint, replacementPoint);
      i += 2;
    }
  }

  return addPoints(nextShape, pointsRequired);
};

var add = function add(shape, pointsRequired) {
  return addPoints((0, _cubify["default"])(shape), pointsRequired);
};

var _default = add;
exports["default"] = _default;