"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _helpers = require("./helpers");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var countLinePoints = function countLinePoints(lines) {
  return lines.reduce(function (count, points) {
    return count + countPoints(points);
  }, 0);
};

var countPoints = function countPoints(points) {
  return points.length - (isJoined(points) ? 1 : 0);
};

var isJoined = function isJoined(points) {
  var firstPoint = points[0];
  var lastPoint = points[points.length - 1];
  return firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y;
};

var joinLines = function joinLines(lines) {
  return lines.reduce(function (shape, line) {
    return [].concat(_toConsumableArray(shape), _toConsumableArray(line));
  }, []);
};

var moveIndex = function moveIndex(s, offset) {
  return (0, _helpers.applyFuncToShapes)(movePointsIndex, s, offset);
};

var movePointsIndex = function movePointsIndex(shape, offset) {
  var lines = splitLines(shape);
  var count = countLinePoints(lines);
  var normalisedOffset = (offset % count + count) % count;

  if (!normalisedOffset) {
    return shape;
  }

  var _nextIndex = nextIndex(lines, normalisedOffset),
      lineIndex = _nextIndex.lineIndex,
      pointIndex = _nextIndex.pointIndex;

  var reorderedLines = reorderLines(lines, lineIndex);
  var firstLine = reorderPoints(reorderedLines[0], pointIndex);

  var restOfLines = _toConsumableArray(reorderedLines).splice(1);

  return joinLines([firstLine].concat(_toConsumableArray(restOfLines)));
};

var nextIndex = function nextIndex(lines, offset) {
  for (var i = 0, l = lines.length; i < l; i++) {
    var count = countPoints(lines[i]);

    if (offset <= count - 1) {
      return {
        lineIndex: i,
        pointIndex: offset
      };
    }

    offset -= count;
  }
};

var reorderLines = function reorderLines(lines, offset) {
  return _toConsumableArray(lines).splice(offset).concat(_toConsumableArray(lines).splice(0, offset));
};

var reorderPoints = function reorderPoints(points, offset) {
  if (!offset) {
    return points;
  }

  var nextPoints = [{
    x: points[offset].x,
    y: points[offset].y,
    moveTo: true
  }].concat(_toConsumableArray(_toConsumableArray(points).splice(offset + 1)));

  if (isJoined(points)) {
    return [].concat(_toConsumableArray(nextPoints), _toConsumableArray(_toConsumableArray(points).splice(1, offset)));
  }

  return [].concat(_toConsumableArray(nextPoints), _toConsumableArray(_toConsumableArray(points).splice(0, offset + 1)));
};

var splitLines = function splitLines(shape) {
  return shape.reduce(function (lines, point) {
    if (point.moveTo) {
      lines.push([]);
    }

    lines[lines.length - 1].push(point);
    return lines;
  }, []);
};

var _default = moveIndex;
exports["default"] = _default;