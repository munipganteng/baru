import arcToBezier from 'svg-arc-to-cubic-bezier';
import { applyFuncToShapes } from './helpers';

var cubifyShape = function cubifyShape(shape) {
  var s = [];

  for (var i = 0, l = shape.length; i < l; i++) {
    var point = shape[i];

    if (point.curve && point.curve.type !== 'cubic') {
      var _shape = shape[i - 1],
          px = _shape.x,
          py = _shape.y;
      var cx = point.x,
          cy = point.y;

      if (point.curve.type === 'arc') {
        var curves = arcToBezier({
          px: px,
          py: py,
          cx: cx,
          cy: cy,
          rx: point.curve.rx,
          ry: point.curve.ry,
          xAxisRotation: point.curve.xAxisRotation,
          largeArcFlag: point.curve.largeArcFlag,
          sweepFlag: point.curve.sweepFlag
        });
        curves.forEach(function (_ref) {
          var x1 = _ref.x1,
              y1 = _ref.y1,
              x2 = _ref.x2,
              y2 = _ref.y2,
              x = _ref.x,
              y = _ref.y;
          s.push({
            x: x,
            y: y,
            curve: {
              type: 'cubic',
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2
            }
          });
        });
      } else if (point.curve.type === 'quadratic') {
        var x1 = px + 2 / 3 * (point.curve.x1 - px);
        var y1 = py + 2 / 3 * (point.curve.y1 - py);
        var x2 = cx + 2 / 3 * (point.curve.x1 - cx);
        var y2 = cy + 2 / 3 * (point.curve.y1 - cy);
        s.push({
          x: cx,
          y: cy,
          curve: {
            type: 'cubic',
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          }
        });
      }
    } else {
      s.push(point);
    }
  }

  return s;
};

var cubify = function cubify(s) {
  return applyFuncToShapes(cubifyShape, s);
};

export default cubify;