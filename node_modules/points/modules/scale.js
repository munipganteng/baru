function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import boundingBox from './boundingBox';
import { applyFuncToShapes } from './helpers';

var scalePoint = function scalePoint(point, scaleFactor, anchorX, anchorY) {
  var p = _objectSpread({}, point);

  p.x = anchorX - (anchorX - p.x) * scaleFactor;
  p.y = anchorY - (anchorY - p.y) * scaleFactor;

  if (point.curve) {
    p.curve = _objectSpread({}, p.curve);

    if (p.curve.type === 'arc') {
      if (p.curve.rx) {
        p.curve.rx = p.curve.rx * scaleFactor;
      }

      if (p.curve.ry) {
        p.curve.ry = p.curve.ry * scaleFactor;
      }
    } else {
      p.curve.x1 = anchorX - (anchorX - p.curve.x1) * scaleFactor;
      p.curve.y1 = anchorY - (anchorY - p.curve.y1) * scaleFactor;

      if (p.curve.type === 'cubic') {
        p.curve.x2 = anchorX - (anchorX - p.curve.x2) * scaleFactor;
        p.curve.y2 = anchorY - (anchorY - p.curve.y2) * scaleFactor;
      }
    }
  }

  return p;
};

var scale = function scale(s, scaleFactor) {
  var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'center';

  var _boundingBox = boundingBox(s),
      bottom = _boundingBox.bottom,
      center = _boundingBox.center,
      left = _boundingBox.left,
      right = _boundingBox.right,
      top = _boundingBox.top;

  var anchorX = center.x;
  var anchorY = center.y;

  switch (anchor) {
    case 'topLeft':
      anchorX = left;
      anchorY = top;
      break;

    case 'topRight':
      anchorX = right;
      anchorY = top;
      break;

    case 'bottomRight':
      anchorX = right;
      anchorY = bottom;
      break;

    case 'bottomLeft':
      anchorX = left;
      anchorY = bottom;
      break;
  }

  return applyFuncToShapes(function (shape) {
    return shape.map(function (point) {
      return scalePoint(point, scaleFactor, anchorX, anchorY);
    });
  }, s);
};

export default scale;