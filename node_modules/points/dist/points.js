(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.Points = {}));
}(this, function (exports) { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      if (i % 2) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }

        ownKeys.forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i]));
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var _slicedToArray$1 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var TAU = Math.PI * 2;

  var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
    var x = _ref.x,
        y = _ref.y;

    x *= rx;
    y *= ry;

    var xp = cosphi * x - sinphi * y;
    var yp = sinphi * x + cosphi * y;

    return {
      x: xp + centerx,
      y: yp + centery
    };
  };

  var approxUnitArc = function approxUnitArc(ang1, ang2) {
    // If 90 degree circular arc, use a constant
    // as derived from http://spencermortensen.com/articles/bezier-circle
    var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);

    var x1 = Math.cos(ang1);
    var y1 = Math.sin(ang1);
    var x2 = Math.cos(ang1 + ang2);
    var y2 = Math.sin(ang1 + ang2);

    return [{
      x: x1 - y1 * a,
      y: y1 + x1 * a
    }, {
      x: x2 + y2 * a,
      y: y2 - x2 * a
    }, {
      x: x2,
      y: y2
    }];
  };

  var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
    var sign = ux * vy - uy * vx < 0 ? -1 : 1;

    var dot = ux * vx + uy * vy;

    if (dot > 1) {
      dot = 1;
    }

    if (dot < -1) {
      dot = -1;
    }

    return sign * Math.acos(dot);
  };

  var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
    var rxsq = Math.pow(rx, 2);
    var rysq = Math.pow(ry, 2);
    var pxpsq = Math.pow(pxp, 2);
    var pypsq = Math.pow(pyp, 2);

    var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

    if (radicant < 0) {
      radicant = 0;
    }

    radicant /= rxsq * pypsq + rysq * pxpsq;
    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);

    var centerxp = radicant * rx / ry * pyp;
    var centeryp = radicant * -ry / rx * pxp;

    var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
    var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;

    var vx1 = (pxp - centerxp) / rx;
    var vy1 = (pyp - centeryp) / ry;
    var vx2 = (-pxp - centerxp) / rx;
    var vy2 = (-pyp - centeryp) / ry;

    var ang1 = vectorAngle(1, 0, vx1, vy1);
    var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

    if (sweepFlag === 0 && ang2 > 0) {
      ang2 -= TAU;
    }

    if (sweepFlag === 1 && ang2 < 0) {
      ang2 += TAU;
    }

    return [centerx, centery, ang1, ang2];
  };

  var arcToBezier = function arcToBezier(_ref2) {
    var px = _ref2.px,
        py = _ref2.py,
        cx = _ref2.cx,
        cy = _ref2.cy,
        rx = _ref2.rx,
        ry = _ref2.ry,
        _ref2$xAxisRotation = _ref2.xAxisRotation,
        xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,
        _ref2$largeArcFlag = _ref2.largeArcFlag,
        largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,
        _ref2$sweepFlag = _ref2.sweepFlag,
        sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;

    var curves = [];

    if (rx === 0 || ry === 0) {
      return [];
    }

    var sinphi = Math.sin(xAxisRotation * TAU / 360);
    var cosphi = Math.cos(xAxisRotation * TAU / 360);

    var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
    var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

    if (pxp === 0 && pyp === 0) {
      return [];
    }

    rx = Math.abs(rx);
    ry = Math.abs(ry);

    var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }

    var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),
        _getArcCenter2 = _slicedToArray$1(_getArcCenter, 4),
        centerx = _getArcCenter2[0],
        centery = _getArcCenter2[1],
        ang1 = _getArcCenter2[2],
        ang2 = _getArcCenter2[3];

    // If 'ang2' == 90.0000000001, then `ratio` will evaluate to
    // 1.0000000001. This causes `segments` to be greater than one, which is an
    // unecessary split, and adds extra points to the bezier curve. To alleviate
    // this issue, we round to 1.0 when the ratio is close to 1.0.


    var ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1.0 - ratio) < 0.0000001) {
      ratio = 1.0;
    }

    var segments = Math.max(Math.ceil(ratio), 1);

    ang2 /= segments;

    for (var i = 0; i < segments; i++) {
      curves.push(approxUnitArc(ang1, ang2));
      ang1 += ang2;
    }

    return curves.map(function (curve) {
      var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),
          x1 = _mapToEllipse.x,
          y1 = _mapToEllipse.y;

      var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),
          x2 = _mapToEllipse2.x,
          y2 = _mapToEllipse2.y;

      var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),
          x = _mapToEllipse3.x,
          y = _mapToEllipse3.y;

      return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
    });
  };

  var angleFromSides = function angleFromSides(a, b, c) {
    var r = Math.acos((Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / (2 * a * b));
    return r * (180 / Math.PI);
  };

  var applyFuncToShapes = function applyFuncToShapes(f, s) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (isShapeArray(s)) {
      return s.map(function (shape) {
        return f.apply(void 0, [shape].concat(args));
      });
    }

    return f.apply(void 0, [s].concat(args));
  };

  var getShapeArray = function getShapeArray(s) {
    return isShapeArray(s) ? s : [s];
  };

  var linearLength = function linearLength(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  };

  var isShapeArray = function isShapeArray(s) {
    return Array.isArray(s[0]);
  };

  var numberAtInterval = function numberAtInterval(a, b, interval) {
    var c = a === b ? 0 : Math.abs(b - a);
    return c === 0 ? a : a < b ? a + c * interval : a - c * interval;
  };

  var cubifyShape = function cubifyShape(shape) {
    var s = [];

    for (var i = 0, l = shape.length; i < l; i++) {
      var point = shape[i];

      if (point.curve && point.curve.type !== 'cubic') {
        var _shape = shape[i - 1],
            px = _shape.x,
            py = _shape.y;
        var cx = point.x,
            cy = point.y;

        if (point.curve.type === 'arc') {
          var curves = arcToBezier({
            px: px,
            py: py,
            cx: cx,
            cy: cy,
            rx: point.curve.rx,
            ry: point.curve.ry,
            xAxisRotation: point.curve.xAxisRotation,
            largeArcFlag: point.curve.largeArcFlag,
            sweepFlag: point.curve.sweepFlag
          });
          curves.forEach(function (_ref) {
            var x1 = _ref.x1,
                y1 = _ref.y1,
                x2 = _ref.x2,
                y2 = _ref.y2,
                x = _ref.x,
                y = _ref.y;
            s.push({
              x: x,
              y: y,
              curve: {
                type: 'cubic',
                x1: x1,
                y1: y1,
                x2: x2,
                y2: y2
              }
            });
          });
        } else if (point.curve.type === 'quadratic') {
          var x1 = px + 2 / 3 * (point.curve.x1 - px);
          var y1 = py + 2 / 3 * (point.curve.y1 - py);
          var x2 = cx + 2 / 3 * (point.curve.x1 - cx);
          var y2 = cy + 2 / 3 * (point.curve.y1 - cy);
          s.push({
            x: cx,
            y: cy,
            curve: {
              type: 'cubic',
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2
            }
          });
        }
      } else {
        s.push(point);
      }
    }

    return s;
  };

  var cubify = function cubify(s) {
    return applyFuncToShapes(cubifyShape, s);
  };

  var linearPoints = function linearPoints(from, to) {
    return [{
      x: numberAtInterval(from.x, to.x, 0.5),
      y: numberAtInterval(from.y, to.y, 0.5)
    }, to];
  };

  var curvedPoints = function curvedPoints(from, to) {
    var _to$curve = to.curve,
        x1 = _to$curve.x1,
        y1 = _to$curve.y1,
        x2 = _to$curve.x2,
        y2 = _to$curve.y2;
    var A = {
      x: from.x,
      y: from.y
    };
    var B = {
      x: x1,
      y: y1
    };
    var C = {
      x: x2,
      y: y2
    };
    var D = {
      x: to.x,
      y: to.y
    };
    var E = {
      x: numberAtInterval(A.x, B.x, 0.5),
      y: numberAtInterval(A.y, B.y, 0.5)
    };
    var F = {
      x: numberAtInterval(B.x, C.x, 0.5),
      y: numberAtInterval(B.y, C.y, 0.5)
    };
    var G = {
      x: numberAtInterval(C.x, D.x, 0.5),
      y: numberAtInterval(C.y, D.y, 0.5)
    };
    var H = {
      x: numberAtInterval(E.x, F.x, 0.5),
      y: numberAtInterval(E.y, F.y, 0.5)
    };
    var J = {
      x: numberAtInterval(F.x, G.x, 0.5),
      y: numberAtInterval(F.y, G.y, 0.5)
    };
    var K = {
      x: numberAtInterval(H.x, J.x, 0.5),
      y: numberAtInterval(H.y, J.y, 0.5)
    };
    return [{
      x: K.x,
      y: K.y,
      curve: {
        type: 'cubic',
        x1: E.x,
        y1: E.y,
        x2: H.x,
        y2: H.y
      }
    }, {
      x: D.x,
      y: D.y,
      curve: {
        type: 'cubic',
        x1: J.x,
        y1: J.y,
        x2: G.x,
        y2: G.y
      }
    }];
  };

  var points = function points(from, to) {
    return to.curve ? curvedPoints(from, to) : linearPoints(from, to);
  };

  var addPoints = function addPoints(shape, pointsRequired) {
    if (isNaN(pointsRequired)) {
      throw Error('`add` function must be passed a number as the second argument');
    }

    var nextShape = _toConsumableArray(shape);

    for (var i = 1; i < nextShape.length;) {
      if (nextShape.length >= pointsRequired) {
        return nextShape;
      }

      var to = nextShape[i];

      if (to.moveTo) {
        i++;
      } else {
        var from = nextShape[i - 1];

        var _points = points(from, to),
            _points2 = _slicedToArray(_points, 2),
            midPoint = _points2[0],
            replacementPoint = _points2[1];

        nextShape.splice(i, 1, midPoint, replacementPoint);
        i += 2;
      }
    }

    return addPoints(nextShape, pointsRequired);
  };

  var add = function add(shape, pointsRequired) {
    return addPoints(cubify(shape), pointsRequired);
  };

  var angle = function angle(triangle) {
    var _triangle$ = _slicedToArray(triangle[0], 2),
        ax = _triangle$[0],
        ay = _triangle$[1];

    var _triangle$2 = _slicedToArray(triangle[1], 2),
        bx = _triangle$2[0],
        by = _triangle$2[1];

    var _triangle$3 = _slicedToArray(triangle[2], 2),
        cx = _triangle$3[0],
        cy = _triangle$3[1];

    var a = linearLength(ax, ay, bx, by);
    var b = linearLength(bx, by, cx, cy);
    var c = linearLength(cx, cy, ax, ay);
    return angleFromSides(a, b, c);
  };

  var curved = function curved(shape) {
    return shape.reduce(function (c, _ref) {
      var curve = _ref.curve;
      return curve ? true : c;
    }, false);
  };

  var decurve = function decurve(shape) {
    var accuracy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    if (!curved(shape)) {
      return shape;
    }

    var s = cubify(shape);
    var d = [];
    s.map(function (point, i) {
      if (point.curve) {
        var prevPoint = s[i - 1];

        if (prevPoint.x !== point.x || prevPoint.y !== point.y) {
          straighten(prevPoint, point, accuracy).map(function (p) {
            return d.push(p);
          });
        }
      } else {
        d.push(point);
      }
    });
    return d;
  };

  var straight = function straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy) {
    var t1 = [[cx1, cy1], [x2, y2], [x1, y1]];
    var t2 = [[cx2, cy2], [x1, y1], [x2, y2]];
    return angle(t1) < accuracy && angle(t2) < accuracy;
  };

  var straighten = function straighten(prevPoint, point, accuracy) {
    var x1 = prevPoint.x,
        y1 = prevPoint.y;
    var x2 = point.x,
        y2 = point.y,
        curve = point.curve;
    var cx1 = curve.x1,
        cy1 = curve.y1,
        cx2 = curve.x2,
        cy2 = curve.y2;

    if (straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy)) {
      return [point];
    }

    var _curvedPoints = curvedPoints(prevPoint, point),
        _curvedPoints2 = _slicedToArray(_curvedPoints, 2),
        midPoint = _curvedPoints2[0],
        lastPoint = _curvedPoints2[1];

    return [].concat(_toConsumableArray(straighten(prevPoint, midPoint, accuracy)), _toConsumableArray(straighten(midPoint, lastPoint, accuracy)));
  };

  var boundingBox = function boundingBox(s) {
    var bottom;
    var left;
    var right;
    var top;
    var shapes = getShapeArray(s);
    shapes.map(function (shape) {
      return decurve(shape).map(function (_ref) {
        var x = _ref.x,
            y = _ref.y;

        if (typeof bottom !== 'number' || y > bottom) {
          bottom = y;
        }

        if (typeof left !== 'number' || x < left) {
          left = x;
        }

        if (typeof right !== 'number' || x > right) {
          right = x;
        }

        if (typeof top !== 'number' || y < top) {
          top = y;
        }
      });
    });
    return {
      bottom: bottom,
      center: {
        x: left + (right - left) / 2,
        y: top + (bottom - top) / 2
      },
      left: left,
      right: right,
      top: top
    };
  };

  var length = function length(shape, accuracy) {
    var s = decurve(shape, accuracy);
    return s.reduce(function (currentLength, _ref, i) {
      var x2 = _ref.x,
          y2 = _ref.y,
          moveTo = _ref.moveTo;

      if (!moveTo) {
        var _s = s[i - 1],
            x1 = _s.x,
            y1 = _s.y;
        currentLength += linearLength(x1, y1, x2, y2);
      }

      return currentLength;
    }, 0);
  };

  var countLinePoints = function countLinePoints(lines) {
    return lines.reduce(function (count, points) {
      return count + countPoints(points);
    }, 0);
  };

  var countPoints = function countPoints(points) {
    return points.length - (isJoined(points) ? 1 : 0);
  };

  var isJoined = function isJoined(points) {
    var firstPoint = points[0];
    var lastPoint = points[points.length - 1];
    return firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y;
  };

  var joinLines = function joinLines(lines) {
    return lines.reduce(function (shape, line) {
      return [].concat(_toConsumableArray(shape), _toConsumableArray(line));
    }, []);
  };

  var moveIndex = function moveIndex(s, offset) {
    return applyFuncToShapes(movePointsIndex, s, offset);
  };

  var movePointsIndex = function movePointsIndex(shape, offset) {
    var lines = splitLines(shape);
    var count = countLinePoints(lines);
    var normalisedOffset = (offset % count + count) % count;

    if (!normalisedOffset) {
      return shape;
    }

    var _nextIndex = nextIndex(lines, normalisedOffset),
        lineIndex = _nextIndex.lineIndex,
        pointIndex = _nextIndex.pointIndex;

    var reorderedLines = reorderLines(lines, lineIndex);
    var firstLine = reorderPoints(reorderedLines[0], pointIndex);

    var restOfLines = _toConsumableArray(reorderedLines).splice(1);

    return joinLines([firstLine].concat(_toConsumableArray(restOfLines)));
  };

  var nextIndex = function nextIndex(lines, offset) {
    for (var i = 0, l = lines.length; i < l; i++) {
      var count = countPoints(lines[i]);

      if (offset <= count - 1) {
        return {
          lineIndex: i,
          pointIndex: offset
        };
      }

      offset -= count;
    }
  };

  var reorderLines = function reorderLines(lines, offset) {
    return _toConsumableArray(lines).splice(offset).concat(_toConsumableArray(lines).splice(0, offset));
  };

  var reorderPoints = function reorderPoints(points, offset) {
    if (!offset) {
      return points;
    }

    var nextPoints = [{
      x: points[offset].x,
      y: points[offset].y,
      moveTo: true
    }].concat(_toConsumableArray(_toConsumableArray(points).splice(offset + 1)));

    if (isJoined(points)) {
      return [].concat(_toConsumableArray(nextPoints), _toConsumableArray(_toConsumableArray(points).splice(1, offset)));
    }

    return [].concat(_toConsumableArray(nextPoints), _toConsumableArray(_toConsumableArray(points).splice(0, offset + 1)));
  };

  var splitLines = function splitLines(shape) {
    return shape.reduce(function (lines, point) {
      if (point.moveTo) {
        lines.push([]);
      }

      lines[lines.length - 1].push(point);
      return lines;
    }, []);
  };

  var offsetPoints = function offsetPoints(shape, x, y) {
    return shape.map(function (point) {
      var p = _objectSpread2({}, point);

      p.x += x;
      p.y += y;

      if (p.curve) {
        p.curve = _objectSpread2({}, p.curve);

        if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {
          p.curve.x1 += x;
          p.curve.y1 += y;
        }

        if (p.curve.type === 'cubic') {
          p.curve.x2 += x;
          p.curve.y2 += y;
        }
      }

      return p;
    });
  };

  var offset = function offset(s) {
    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return applyFuncToShapes(offsetPoints, s, x, y);
  };

  var angle$1 = function angle(x1, y1, x2, y2, a) {
    if (x1 === x2) {
      return y1 >= y2 ? 0 : 180;
    }

    var b = 100;
    var c = linearLength(x2, y2, x1, y1 - b);
    var ang = angleFromSides(a, b, c);
    return x1 < x2 ? ang : 360 - ang;
  };

  var over = function over(shape, length, totalLength, desiredLength) {
    var _shape = shape[length - 2],
        x1 = _shape.x,
        y1 = _shape.y;
    var _shape2 = shape[length - 1],
        x2 = _shape2.x,
        y2 = _shape2.y;
    var segmentLength = linearLength(x1, y1, x2, y2);
    var segmentInterval = (desiredLength - totalLength) / segmentLength + 1;
    return {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2,
      segmentInterval: segmentInterval,
      segmentLength: segmentLength
    };
  };

  var position = function position(shape, interval, accuracy) {
    var s = decurve(shape, accuracy);
    var l = s.length;
    var t = length(s);
    var d = t * interval;

    var _ref = interval > 1 ? over(s, l, t, d) : interval < 0 ? under(s, d) : within(s, l, d),
        x1 = _ref.x1,
        y1 = _ref.y1,
        x2 = _ref.x2,
        y2 = _ref.y2,
        segmentInterval = _ref.segmentInterval,
        segmentLength = _ref.segmentLength;

    return {
      angle: angle$1(x1, y1, x2, y2, segmentLength),
      x: numberAtInterval(x1, x2, segmentInterval),
      y: numberAtInterval(y1, y2, segmentInterval)
    };
  };

  var under = function under(shape, desiredLength) {
    var _shape$ = shape[0],
        x1 = _shape$.x,
        y1 = _shape$.y;
    var _shape$2 = shape[1],
        x2 = _shape$2.x,
        y2 = _shape$2.y;
    var segmentLength = linearLength(x1, y1, x2, y2);
    var segmentInterval = desiredLength / segmentLength;
    return {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2,
      segmentInterval: segmentInterval,
      segmentLength: segmentLength
    };
  };

  var within = function within(shape, length, desiredLength) {
    var currentLength = 0;

    for (var i = 0; i < length; i++) {
      var moveTo = shape[i].moveTo;

      if (!moveTo) {
        var _shape3 = shape[i - 1],
            x1 = _shape3.x,
            y1 = _shape3.y;
        var _shape$i = shape[i],
            x2 = _shape$i.x,
            y2 = _shape$i.y;
        var segmentLength = linearLength(x1, y1, x2, y2);

        if (currentLength + segmentLength >= desiredLength) {
          var segmentInterval = (desiredLength - currentLength) / segmentLength;
          return {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            segmentInterval: segmentInterval,
            segmentLength: segmentLength
          };
        }

        currentLength += segmentLength;
      }
    }
  };

  var isBetween = function isBetween(a, b, c) {
    if (b.curve || c.curve) {
      return false;
    }

    var crossProduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);

    if (Math.abs(crossProduct) > Number.EPSILON) {
      return false;
    }

    var dotProduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y) * (b.y - a.y);

    if (dotProduct < 0) {
      return false;
    }

    var squaredLengthBA = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);

    if (dotProduct > squaredLengthBA) {
      return false;
    }

    return true;
  };

  var removePoints = function removePoints(shape) {
    var s = [];

    for (var i = 0, l = shape.length; i < l; i++) {
      var a = s[s.length - 1];
      var b = shape[i + 1];
      var c = shape[i];

      if (!(a && b && c) || !isBetween(a, b, c)) {
        s.push(c);
      }
    }

    return s;
  };

  var remove = function remove(s) {
    return applyFuncToShapes(removePoints, s);
  };

  var reversePoints = function reversePoints(shape) {
    var m;
    var c;
    return shape.reverse().map(function (_ref, i) {
      var x = _ref.x,
          y = _ref.y,
          moveTo = _ref.moveTo,
          curve = _ref.curve;
      var point = {
        x: x,
        y: y
      };

      if (c) {
        var _c = c,
            x2 = _c.x1,
            y2 = _c.y1,
            x1 = _c.x2,
            y1 = _c.y2;
        point.curve = {
          type: 'cubic',
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        };
      }

      if (i === 0 || m) {
        point.moveTo = true;
      }

      m = moveTo;
      c = curve || null;
      return point;
    });
  };

  var reverse = function reverse(s) {
    return applyFuncToShapes(reversePoints, cubify(s));
  };

  var rotatePoint = function rotatePoint(x, y, c, s, about) {
    var offsetX = about.x,
        offsetY = about.y;
    var relativeX = x - offsetX;
    var relativeY = y - offsetY;
    return [relativeX * c - relativeY * s + offsetX, relativeX * s + relativeY * c + offsetY];
  };

  var rotatePoints = function rotatePoints(shape, angle, about) {
    return shape.map(function (point) {
      var r = angle * Math.PI / 180;
      var c = Math.cos(r);
      var s = Math.sin(r);

      var _rotatePoint = rotatePoint(point.x, point.y, c, s, about),
          _rotatePoint2 = _slicedToArray(_rotatePoint, 2),
          x = _rotatePoint2[0],
          y = _rotatePoint2[1];

      var p = _objectSpread2({}, point, {
        x: x,
        y: y
      });

      if (p.curve) {
        if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {
          var _rotatePoint3 = rotatePoint(p.curve.x1, p.curve.y1, c, s, about),
              _rotatePoint4 = _slicedToArray(_rotatePoint3, 2),
              x1 = _rotatePoint4[0],
              y1 = _rotatePoint4[1];

          p.curve = _objectSpread2({}, p.curve, {
            x1: x1,
            y1: y1
          });
        }

        if (p.curve.type === 'cubic') {
          var _rotatePoint5 = rotatePoint(p.curve.x2, p.curve.y2, c, s, about),
              _rotatePoint6 = _slicedToArray(_rotatePoint5, 2),
              x2 = _rotatePoint6[0],
              y2 = _rotatePoint6[1];

          p.curve = _objectSpread2({}, p.curve, {
            x2: x2,
            y2: y2
          });
        }
      }

      return p;
    });
  };

  var rotate = function rotate(s, angle) {
    var _boundingBox = boundingBox(s),
        about = _boundingBox.center;

    return applyFuncToShapes(rotatePoints, s, angle, about);
  };

  var scalePoint = function scalePoint(point, scaleFactor, anchorX, anchorY) {
    var p = _objectSpread2({}, point);

    p.x = anchorX - (anchorX - p.x) * scaleFactor;
    p.y = anchorY - (anchorY - p.y) * scaleFactor;

    if (point.curve) {
      p.curve = _objectSpread2({}, p.curve);

      if (p.curve.type === 'arc') {
        if (p.curve.rx) {
          p.curve.rx = p.curve.rx * scaleFactor;
        }

        if (p.curve.ry) {
          p.curve.ry = p.curve.ry * scaleFactor;
        }
      } else {
        p.curve.x1 = anchorX - (anchorX - p.curve.x1) * scaleFactor;
        p.curve.y1 = anchorY - (anchorY - p.curve.y1) * scaleFactor;

        if (p.curve.type === 'cubic') {
          p.curve.x2 = anchorX - (anchorX - p.curve.x2) * scaleFactor;
          p.curve.y2 = anchorY - (anchorY - p.curve.y2) * scaleFactor;
        }
      }
    }

    return p;
  };

  var scale = function scale(s, scaleFactor) {
    var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'center';

    var _boundingBox = boundingBox(s),
        bottom = _boundingBox.bottom,
        center = _boundingBox.center,
        left = _boundingBox.left,
        right = _boundingBox.right,
        top = _boundingBox.top;

    var anchorX = center.x;
    var anchorY = center.y;

    switch (anchor) {
      case 'topLeft':
        anchorX = left;
        anchorY = top;
        break;

      case 'topRight':
        anchorX = right;
        anchorY = top;
        break;

      case 'bottomRight':
        anchorX = right;
        anchorY = bottom;
        break;

      case 'bottomLeft':
        anchorX = left;
        anchorY = bottom;
        break;
    }

    return applyFuncToShapes(function (shape) {
      return shape.map(function (point) {
        return scalePoint(point, scaleFactor, anchorX, anchorY);
      });
    }, s);
  };

  exports.add = add;
  exports.boundingBox = boundingBox;
  exports.cubify = cubify;
  exports.length = length;
  exports.moveIndex = moveIndex;
  exports.offset = offset;
  exports.position = position;
  exports.remove = remove;
  exports.reverse = reverse;
  exports.rotate = rotate;
  exports.scale = scale;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
